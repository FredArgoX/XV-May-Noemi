<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive SVG Morph Example</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        svg {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <svg id="my-svg" width="300" height="200" viewBox="0 0 100 100">
        <path id="my-path" d="M50 10 C90 10 90 90 50 90 C10 90 10 10 50 10" fill="blue" />
    </svg>

    <script>
        const svgPath = document.getElementById('my-path');
        let currentD = svgPath.getAttribute('d'); // Initial path
        let animationFrameId;
        const duration = 500; // Animation time in ms
        const breakpoint = 768; // Mobile < 768px, desktop >= 768px

        // Define morph-compatible paths
        const paths = {
            small: 'M50 10 C90 10 90 90 50 90 C10 90 10 10 50 10', // Compact, rounded shape
            large: 'M10 10 L90 10 L90 90 L10 90 Z' // Expanded, rectangular shape (simplified for compatibility)
        };

        // Note: For better morphing, ensure paths have same command types/count. Here, small is curves, large is lines â€“ morphing may look abrupt. Use tools like Adobe Illustrator to make compatible paths.

        // Function to parse 'd' string into commands and numbers array
        function parsePath(d) {
            return d.match(/([MLHVCSQTAZmlhvcsqtaz])|([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/g) || [];
        }

        // Function to serialize array back to 'd' string
        function serializePath(parts) {
            return parts.join('');
        }

        // Linear interpolation between two values
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // Animate morph from startPath to endPath
        function morphPath(startD, endD, duration) {
            const startParts = parsePath(startD);
            const endParts = parsePath(endD);

            // Basic handling for mismatched lengths (pad with last value, but ideally paths should match)
            const maxLength = Math.max(startParts.length, endParts.length);
            while (startParts.length < maxLength) startParts.push(startParts[startParts.length - 1]);
            while (endParts.length < maxLength) endParts.push(endParts[endParts.length - 1]);

            const startTime = performance.now();

            function animate(time) {
                const t = Math.min((time - startTime) / duration, 1); // Progress 0-1
                const newParts = startParts.map((part, i) => {
                    if (isNaN(parseFloat(part))) return part; // Command letter
                    return lerp(parseFloat(startParts[i]), parseFloat(endParts[i]), t);
                });
                svgPath.setAttribute('d', serializePath(newParts));
                if (t < 1) {
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    currentD = endD; // Update current
                }
            }

            cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(animate);
        }

        // Handle resize with debounce for performance
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const width = window.innerWidth;
                const targetD = width < breakpoint ? paths.small : paths.large;
                if (targetD !== currentD) {
                    morphPath(currentD, targetD, duration);
                }
            }, 100); // Debounce by 100ms
        }

        // Initial call and listener
        handleResize();
        window.addEventListener('resize', handleResize);
    </script>
</body>
</html>